# quantbeOA report
This is the report of this OA

## CI/CD ##
I don't have experience using implementing C# CI/CD pipelines, but I do have experience implementing NodeJS CI/CD pipelines on Gitlab. I will assume that the implementation for them will be very similar, because CI/CD is nothing but just auto testing and auto deployment. How it works in a software development cycle is test cases are added first for all functions and routes, then once a developer updated the routes or the functions and push to his branch on github, a set of tests will be run automatically, based on the result of all the test cases, developers can know if there is anything wrong with his code. Once he passes all the tests, then he is good for merging to main development branch, note here, it does not mean his code is bug free, passing all test cases is not bug free(This is mostly about CI). Once merge to development branch is done and his team completes a mailstone, then this development branch will be merged to production branch(there might be more steps before merging to production branch, depends on company needs), a script will run automatically to deploy the new changes, this is the CD part. 

### My experience with CI/CD with gitlab ###
I will mainly talk about my experience in gitlab CI/CD. So first, Gitlab needs users to register a device as runner on Gitlab, I personally won't choose shared Runner because it is shared among all users and it can be extremly slow. For private runner, user will need a device to go through all the config steps and register that device as a Runner, then set up the running environment. Once it's done, developer needs to upload some env vars in gitlab and implement the CI/CD script for Gitlab CI/CD. Now the user needs to run the runner in that particular machine, then everytime a push happens, that machine will excute the test and it will show the result in gitlab. 

## Some thoughts ##
I'm not sure the use case of this encoded url. I understand that there will be some important infomation from the url, 

I might understand the requirement wrong, this encoded url is return back to frontend, as it being said, any user can make an API call tho this encode url route and get the encrypted url. Maybe authentication will be added later on, but I feel this encoding url feature can become a microservice such that takes the origin url from the req body and maybe also some other info from body, then use the encoded url 